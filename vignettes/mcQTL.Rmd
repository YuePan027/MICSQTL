---
title: "mcQTL: Multi-omic and Cell-type-specific Quantitative Trait Loci"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{mcQTL: Multi-omic and Cell-type-specific Quantitative Trait Loci}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
abstract: >
  mcQTL (Multi-omic and Cell-type-specific Quantitative Trait Loci) is a tool that estimates cell type proportions in bulk proteomes by either using single data source reference or borrowing information in matched transcriptomes. Based on the deconvoluted cellular composition, mcQTL further performs Quantitative Trait Loci mapping at cellular resolution, as well as integrates and visualizes multi-source profiles at bulk and cell type levels. 
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Install

```{r setup, message = FALSE}
#devtools::install_github("YuePan027/mcQTL@dev") # from dev branch
library(mcQTL)
library(ggplot2)
library(GGally)
```

# Quick start

## Cell-type proportion deconvolution 

This step is used to obtain cell-type proportion. 

A `SummarizedExperiment` object with bulk protein expression contained in `counts` slot, and a "signature matrix" which serves as a reference of known cellular signatures contained as an element in `metadata` slot is required as input file. Note that the proteins in signature matrix can be different from that in assay, but only common proteins will be used to do deconvolution. 

In this current version, only `CIBERSORT` and `nnls` are supported as the deconvolution methods.

```{r decov1}
se <- SummarizedExperiment(assays = list(counts = mcQTL::protein_data),
                           rowData = mcQTL::anno_protein)
metadata(se) <- list(sig_matrix = mcQTL::ref_data)
se <- deconv(se, "cibersort")
```

This step might take a few minutes if there are many proteins in the signature matrix. The cell-type proportion estimates for each sample will be stored as an element (`prop`) in `metadata` slot.

```{r decov2, fig.width=7, fig.height=5, warnings = F}
head(se@metadata$prop)

ggplot(cbind(data.frame(reshape2::melt(se@metadata$prop), mcQTL::meta)), 
       aes(x = Var2, y = value, fill = Var2)) +
    geom_point(position = position_jitterdodge(jitter.width = 0.1,
                                               dodge.width = 0.7),
               aes(fill = Var2, color = Var2),
               pch = 21, alpha = 0.5) +
    geom_boxplot(lwd=0.7, outlier.shape = NA) +
    theme_classic() +
    facet_wrap(~disease) +
    xlab("Cell type") + ylab("Estimated proportion")
```

Alternatively, if there are cell-type proportion estimates results generated using other methods or obtained from other sources, just save that as an element (`prop`) in `metadata` slot and this deconvolution step can be skipped. Note that the samples in the cell-type proportion estimates must match the samples from bulk protein expression data.


## Feature filtering

The feature filtering can be applied at both proteins and SNPs. This step is optional but highly recommended to filter out features that are not very informative or do not have much biological insights. Note that this function is required to run even no filtering is expected to be done (just set `filter_method = "null"`) to obtain a consistent object format for downstream analysis.

To apply feature filtering, annotation files for proteins and SNPs are required. 
The annotation file for proteins should be stored in `rowData()`, where each row corresponds to a protein with its symbol as row names. The first column should be a character vector indicating which chromosome each protein or gene is on. In addition, it should contain at least a "Start" column with numeric values indicating the start position on that chromosome, a "End" column with numeric values indicating the end position on that chromosome and a "Symbol" column as a unique name for each protein.

```{r filter1}
head(rowData(se))
```

The information from genetic variants should be stored in a P (the number of SNP) by N (the number of samples, should match the sample in `counts` slot) matrix contained as an element (`SNP_data`) in `metadata` slot. Each matrix entry corresponds to the genotype group indicator (0 for 0/0, 1 for 0/1 and 2 for 1/1) for a sample at a genetic location. The annotations of these SNP should be stored as an element (`anno_SNP`) in `metadata` slot. It should include at least the following columns:  (1) "CHROM" (which chromosome the SNP is on); (2) "POS" (position of that SNP) and (3) "ID" (a unique identifier for each SNP, usually a combination of chromosome and its position).

The example SNP data provided here were restricted to chromosome 9 only. In practice, the SNPs may from multiple or even all chromosomes.

```{r filter2}
se@metadata$SNP_data <- mcQTL::SNP_data
se@metadata$anno_SNP <- mcQTL::anno_SNP
head(se@metadata$anno_SNP)
```

For filtering at protein or gene level, only those symbols contained in `target_protein` argument will be kept for csQTL analysis in the next step. By default, all proteins will be used.

For filtering at SNP level, there are three options: (1) only those symbols contained in `target_SNP` argument will be kept and if not provided, all SNPs will be used for further filtering; (2) filter out the SNPs that have minor allele frequency below the threshold defined by `filter_allele` argument (`filter_method = "allele"`) and (3) restrict to cis-regulatory variants, i.e. the SNPs up to 1 Mb proximal to the start of the gene (`filter_method = "distance"`).

The results after filtering will be stored as an element (`choose_SNP_list`) in `metadata` slot. It is a list with the length of the number of proteins for downstream analysis. Each element stores the index of SNPs to be tested for corresponding protein. The proteins with no SNPs correspond to it will be removed from the returned list.

To simplify the analysis, we only kept 10 targeted proteins from chromosome 9 as an example.

```{r filter3}
target_protein <- rowData(se)[rowData(se)$Chr == 9,][1:10, "Symbol"]
se <- feature_filter(se, target_protein = target_protein, 
                     filter_method = c("allele", "distance"), 
                     filter_allele = 0.25,
                     filter_geno = 0.05,
                     ref_position = "TSS")           
```

In this example, the number of SNPs corresponding to each protein after filtering ranges from 6 to 23.

```{r filter4}
unlist(lapply(se@metadata$choose_SNP_list, length))
```


## csQTL analysis

In this step, the `TOAST` method is implemented for cell-type-specific differential expression analysis based on samples' genotype. 

The result will be stored as an element (`TOAST_output`) in `metadata` slot. It is a list with the same length as tested proteins where each element consists of a table including protein symbol, SNP ID and p-values from each cell type. A significant p-value indicates that the protein expression is different among the sample from different genotype groups.

```{r csQTL1}
system.time(se <- csQTL(se))

```

We can check the results from csQTL analysis for the first target protein by calling:

```{r csQTL2}
head(se@metadata$TOAST_output[[1]])
```


## Cross-source cell-type proportion deconvolution (optional)

Besides cell-type proportion deconvolution using single source as shown above, we can also consider cross-source cell-type proportion deconvolution if we have matched samples from a different sources. In the example below, we show how to estimate cell-type proportion from protein data by using an initial proportion estimated from gene expression. To explain the idea, we use randomly selected proteins as marker proteins. But in practice, more meaningful proteins should be included.

```{r cross, message = F}
prop_gene <- mcQTL::prop_gene
set.seed(1234)
in_example <- sample(1:nrow(mcQTL::protein_data), size=500, replace =F)
example_mrk <- rownames(mcQTL::protein_data)[in_example]
se <- cross_prop(se, ini_prop = prop_gene, mrk_prot = example_mrk)

ggplot(cbind(data.frame(reshape2::melt(se@metadata$cross_prop), mcQTL::meta)), 
       aes(x = Var2, y = value, fill = Var2)) +
    geom_point(position = position_jitterdodge(jitter.width = 0.1,
                                               dodge.width = 0.7),
               aes(fill = Var2, color = Var2),
               pch = 21, alpha = 0.5) +
    geom_boxplot(lwd=0.7, outlier.shape = NA) +
    theme_classic() +
    facet_wrap(~disease) +
    xlab("Cell type") + ylab("Estimated proportion")
```


## TCA deconvolution (optional)

The cell-type-specific expression per bulk sample can also be estimated using `TCA` deconvolution method given cellular composition (stored in `prop` in `metadata` slot). The output will be stored as an element (`TCA_deconv`) in `metadata` slot. It is a list with the length of the number of cell types (same as cell types in `prop` in `metadata` slot). Each element stores a deconvoluted protein expression per bulk sample. Below is an example to check the deconvoluted cellular expression for the first cell type (restricted to first 5 proteins and first 5 samples):

```{r tca}
se <- TCA_deconv(se)
se@metadata$TCA_deconv[["CellType_1"]][1:5,1:5]
```

The figure below depict the cell-type-specific expression in one example protein.

```{r deconv}
res <- se@metadata$TCA_deconv
idx <- which(rownames(assay(se)) == "Protein_6")
df_res <- do.call("cbind", lapply(1:length(res), function(i){
    df <- data.frame(t(res[[i]][idx, , drop = F]))
    colnames(df) <- names(res)[i]
    return(df)
}))
idx <- which(se@metadata$anno_SNP$ID == "9:137238591")
table(se@metadata$SNP_data[idx,])
ggplot(data.frame(reshape2::melt(data.frame(cbind(df_res, genotype = se@metadata$SNP_data[idx,])), id.vars = c("genotype"))), 
       aes(x = factor(genotype), y = value, fill = variable)) +
    geom_point(position = position_jitterdodge(jitter.width = 0.1,
                                               dodge.width = 0.7),
               aes(fill = variable, color = variable),
               pch = 21, alpha = 0.5) +
    geom_boxplot(lwd=0.7, outlier.shape = NA) +
    theme_classic() +
    facet_wrap(~variable, scales = "free") +
    xlab("Genotype") + ylab("Deconvoluted expression")
```

Such patterns may not be observed from bulk level.

```{r bulk}
df <- assay(se)
df <- df[which(rownames(df) == "Protein_6"),]
df_test <- data.frame(value = as.vector(t(df)), genotype = se@metadata$SNP_data[idx,])
ggplot(df_test, 
       aes(x = factor(genotype), y = value)) +
    geom_jitter(pch = 21, alpha = 0.5) +
    geom_boxplot(lwd=0.7, outlier.shape = NA) +
    theme_classic() +
    xlab("Genotype") + ylab("Deconvoluted expression")
```

# Integrative analysis

AJIVE (Angle based Joint and Individual Variation Explained) is useful when there are multiple data matrices measured on the same set of samples. It decomposes each data matrix as three parts: (1) Joint variation across data types (2) Individual structured variation for each data type and (3) Residual noise. 

It is similar as principal component analysis (PCA), but principal component analysis only takes a single data set and decomposes it into modes of variation that maximize variation. AJIVE finds joint modes of variation from multiple data sources. 

Common normalized scores are one of the desirable output to explore the joint behavior that is shared by different data sources. Below we show the visualization of common normalized scores. It is clear that the disease status of these samples are well separated by the first common normalized scores.

```{r ajive}
se@metadata$gene_data <- mcQTL::gene_data
se@metadata$meta <- mcQTL::meta
se <- ajive_decomp(se)
cns_plot(se, score = "cns_1", group_var = "disease", 
         scatter = T, scatter_x = "cns_1", scatter_y = "cns_2")

```

## Comparison to PCA

```{r pca}
pca_res <- prcomp(t(assay(se)), rank. = 3, scale. = F)
pca_res_protein <- data.frame(pca_res[["x"]])
pca_res_protein <- cbind(pca_res_protein, mcQTL::meta$disease)
colnames(pca_res_protein)[4] = 'disease'
GGally::ggpairs(pca_res_protein, columns = 1:3, aes(color = disease, alpha = 0.5),
        upper = list(continuous = "points")) + theme_classic()


pca_res <- prcomp(t(se@metadata$gene_data), rank. = 3, scale. = F)
pca_res_gene <- data.frame(pca_res[["x"]])
pca_res_gene <- cbind(pca_res_gene, mcQTL::meta$disease)
colnames(pca_res_gene)[4] = 'disease'
GGally::ggpairs(pca_res_gene, columns = 1:3, aes(color = disease, alpha = 0.5),
        upper = list(continuous = "points")) + theme_classic()
```

## Cell-type-specific AJIVE

The integrative analysis can also be done at cell-type-specific level. TCA deconvolution for the secondary data set is required. Here, we deconvolute gene expression in additional to protein expression and restrict to the first cell type as an illustration example.

```{r ajive2}
se <- TCA_deconv(se, test = "gene_data", prop = mcQTL::prop_gene)
se <- ajive_decomp(se, level = "CellType_1")
cns_plot(se, score = "cns_1", group_var = "disease", 
         scatter = T, scatter_x = "cns_1", scatter_y = "cns_2")

```


